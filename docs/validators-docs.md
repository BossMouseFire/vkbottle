# Применение валидаторов

Валидаторы - штуки, контроллирующие прохождения аргументов под шаблон сообщения. Давайте напишем простую обработку сообщения с простым аргументом

```python
@bot.on.message_both.lower('мне <some> лет')
async def wrapper(ans: Message, some):
    await ans(f'Все ясно! @id{ans.from_id} (этому человеку) {some} лет')
```

Теперь реакция бота на сообщения шаблона `мне 5 лет` будет указанным сообщением. Но вот проблема! Мы не можем контроллировать вхождение аргумента, точнее мы можем, но только применяя условие с проверкой на `isdigit()` и какими-то другими заморочками

**Валидаторы!** Вот то что нам нужно. С помощью них мы сможем контроллировать вхождения аргументов по определенным условиям с помощью встроенного в модуль патчера (`VKBottle Patcher v0.2`)  и собственного языка разметки основанного на регексах - VBML - VKBottle Marking Language

### Изучаем аргументы сообщений с точки зрения VBML

VBML - простой язык разметки на регексах, то что нам нужно ведь в него встроена валидация для аргуметов

Для того присвоить аргументу валидатор нужно указать его после названия аргумента, например так:

`<some:validator>`

Проверьте работу VBML прямо сейчас. Создайте обработчик с указанным кодом прямо сейчас:

```python
@bot.on.message_both.lower('/<some:validator>')
async def wrapper(ans: Message, some):
    await ans(f'Введена команда {some}!')
```

Теперь при итерировании этого обработчика `some` будет проверяться по валидатору `validator`

Этот самый `validator` является тестовым валидатором и просто скажет вам о том, что все работает правильно, а именно валидация VBML

**Вы можете использовать несколько валидаторов, даже одинаковых сразу**

`<some:validator:validator2>`

### Встроенные валидаторы

Класс со встроенными валидаторами вы можете увидеть [здесь](../vkbottle/framework/patcher/validators/vbml.py)

На данный момент встроенными работающими валидаторами для аргументов являются:

| Название | Применение     | Описание                                                                                              |
|:--------:|:--------------:|:-----------------------------------------------------------------------------------------------------:|
| int      | `<some:int>`   | Проверяет аргумент на то, что он является целым числом и в данном варианте возвращает его в этом типе |
| float    | `<some:float>` | Принимает числа и целые, и с плавающей точкой. Возвращает в типе float                                |
| url      | `<some:url>`   | Проверяет аргумент на прибывание ссылкой с протоколом. Использует urllib.urlparse для проверки        |

### Создание собственных валидаторов

Главной фишкой валидаторов является не использование трех стандартных, а создание собственных. Я хочу учесть кое-какую особенность, пользуясь этим свойством патчера

Давайте создадим кастомный класс собственных валидаторов, наследуя стандартный класс `VBMLValidators`:

```python
from vkbottle.validators import VBMLValidators
# bot = Bot(...)

class MyValidators(VBMLValidators):
    pass

bot.patcher(validators=MyValidators)
```

Теперь мы можем создавать собственные валидаторы. При создании валидаторов вам нужно придеживаться нескольких правил оформления:

* Функции валидаторов должны быть асинхронными

* Фунции должны быть классовыми (не staticmethod) и содержать один аргумент, который будет принимать валидируемый аргумент

* Аргумент будет считаться правильным если валидатор вернет все что угодно кроме None

Я собираюсь учесть проблему, где, благодаря трудностям славянских языков для указания возраста мы можем использовать и `лет`, и `года`, и `год`

```python
class MyValidators(VBMLValidators):
    async def years(self, text):
        if text in ['лет', 'года', 'год']:
            return text
        return
```

Теперь напишу конечный обработчик:

```python
@bot.on.message_both.lower('мне <some:int> <j:years>')
async def wrapper(ans: Message, some, j):
    if some >= 18:
        await ans(f'Ого тебе уже {some} {j}')
    else:
        await ans(f'Эм тебе еще только {some} {j}')
```

Ура!

## Аргументы валидаторов

Создам простой валидатор startswith для аргументов, для этого в класс MyValidators добавлю новый обработчик:  

```python
async def startswith(self, value: str, start: str):
    if value.startswith(start):
        return value
```

Теперь я могу использовать этот валидатор:

```python
@bot.on.message_both.lower('президент <name:startswith[Ким]>')
async def wrapper(ans: Message, name):
    await ans(f'Дада! Президент {name}')
```

* Аргументов может быть много, они перечисляются через запятую без пробелов  
* Если аргумент цифра - он автоматически в нее конвертируется 
* Стандартный тип аргумента `int`